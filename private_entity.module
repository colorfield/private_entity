<?php

/**
 * @file
 * Contains private_entity.module.
 */

use Drupal\entity_tools\FieldTools;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\node\NodeInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\field\Entity\FieldConfig;

define('PRIVATE_ENTITY_REALM', 'private_entity_access');

/**
 * Implements hook_help().
 */
function private_entity_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the private_entity module.
    case 'help.page.private_entity':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Simple per entity access control.') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_node_access_records().
 */
function private_entity_node_access_records(NodeInterface $node) {
  // This hook is called after saving a node.
  // @todo Code design: is private should be set to true by default
  // now that private_entity_field_config_insert takes care of setting
  // initial values on existing content.
  $isPrivate = FALSE;
  $privateFieldName = FieldTools::getFieldNameFromType($node, 'private_entity');
  if (!is_null($privateFieldName) && $node->hasField($privateFieldName)) {
    $privateFieldValue = $node->get($privateFieldName)->getValue();
    // @todo define a field type 'is private' that can be appended on entities.
    // @todo config to set message or not.
    if (isset($privateFieldValue[0]['value'])
      && (int) $privateFieldValue[0]['value'] === 1) {
      $isPrivate = TRUE;
      // @todo use messenger and require Drupal 8.5
      drupal_set_message(t('This content was set as private.'), 'warning');
    }
    else {
      drupal_set_message(t('This content was set as public.'));
    }
  }

  if ($isPrivate) {
    /** @var \Drupal\private_entity\PrivateEntityInterface $privateEntityService */
    $privateEntityService = \Drupal::service('private_entity');
    // If a user can view, it becomes eligible to update or delete.
    // Otherwise just ignore the grant for other accounts.
    $accounts = $privateEntityService->getGrantedAccounts(['view']);
    foreach ($accounts as $account) {
      if ($account instanceof AccountInterface) {
        // Evaluation to update or delete can be done here.
        // Or simply during the evaluation of hook_node_grants()
        // but with perf issue.
        // @todo evaluate has permission to update
        $grantUpdate = 0;
        // @todo evaluate has permission to delete
        $grantDelete = 0;
        foreach ($node->getTranslationLanguages(TRUE) as $translationLanguage) {
          if ($node->hasTranslation($translationLanguage->getId())) {
            $grants[] = [
              'realm' => PRIVATE_ENTITY_REALM,
              'gid' => $account->id(),
              'grant_view' => 1,
              'grant_update' => $grantUpdate,
              'grant_delete' => $grantDelete,
              'langcode' => $translationLanguage->getId(),
            ];
          }
        }
      }
    }

    // Exception for the admin GID.
    foreach ($node->getTranslationLanguages(TRUE) as $translationLanguage) {
      if ($node->hasTranslation($translationLanguage->getId())) {
        $grants[] = [
          'realm' => PRIVATE_ENTITY_REALM,
          'gid' => 0,
          'grant_view' => 1,
          'grant_update' => 1,
          'grant_delete' => 1,
          'langcode' => $translationLanguage->getId(),
        ];
      }
    }

    return $grants;
  }
}

/**
 * Implements hook_node_grants().
 */
function private_entity_node_grants(AccountInterface $account, $op) {
  // This hook is called each time access to a node needs to be determined.
  $grants = [];
  if (in_array('administrator', $account->getRoles())) {
    // Gid to view, update, delete.
    $grants[PRIVATE_ENTITY_REALM][] = 0;
    return $grants;
  }
  // @todo roles exclusion (bypass access rule) from a new permission
  if ($account->id() != 0) {
    // Otherwise return uid, might match entry in table.
    $grants[PRIVATE_ENTITY_REALM][] = $account->id();
  }
  return $grants;
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function private_entity_field_config_insert(FieldConfig $field) {
  if ($field->getType() === 'private_entity' && !$field->isSyncing() && !$field->isDeleted()) {
    /** @var \Drupal\private_entity\PrivateEntityInterface $privateEntityService */
    $privateEntityService = \Drupal::service('private_entity');
    // Set private_entity values for existing entities.
    $oldCount = $privateEntityService->initExistingEntities(
      $field->getTargetEntityTypeId(),
      $field->getTargetBundle(),
      $field->getFieldStorageDefinition()->getName()
    );
    if ($oldCount > 0) {
      drupal_set_message(t('%count existing entities have been set as public.', [
        '%count' => $oldCount,
      ]));
    }
  }
}
