<?php

/**
 * @file
 * Contains private_entity.module.
 */

use Drupal\entity_tools\EntityTools;
use Drupal\entity_tools\FieldTools;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\node\NodeInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\field\Entity\FieldConfig;

define('PRIVATE_ENTITY_REALM', 'private_entity_access');

/**
 * Implements hook_help().
 */
function private_entity_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the private_entity module.
    case 'help.page.private_entity':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Simple per entity access control.') . '</p>';
      return $output;

    default:
  }
}

/**
 * Returns an array of accounts that have access to the private entities.
 *
 * @param string $op
 *   Operation: view, update, delete.
 *
 * @return array
 *   Array of AccountInterface instances.
 */
function _private_entity_get_accounts($op = 'view') {
  $result = [];
  // Possible coverage of other operations
  // currently limited to 'view'.
  $entityTools = \Drupal::service('entity_tools');
  if ($entityTools instanceof EntityTools) {
    $result = $entityTools->getUsersByPermission('private entity view access');
  }
  return $result;
}

/**
 * Initializes the value as public of existing entities.
 *
 * @param string $entity_type_id
 *   Entity type id.
 * @param string $entity_bundle
 *   Entity bundle name.
 * @param string $field_name
 *   Field name.
 *
 * @return int
 *   Amount of entries that were updated.
 */
function _private_entity_init_old_entries($entity_type_id, $entity_bundle, $field_name) {
  $entityTypeManager = \Drupal::service('entity_type.manager');
  $storage = $entityTypeManager->getStorage($entity_type_id);
  $bundleKey = $storage->getEntityType()->getKey('bundle');
  $entityQuery = \Drupal::entityQuery($entity_type_id);
  $entityQuery->condition($bundleKey, $entity_bundle);
  $entityIds = $entityQuery->execute();

  $updated = 0;
  foreach ($entityIds as $entityId) {
    $entity = $storage->loadUnchanged($entityId);
    // @todo review multilingual
    // @todo set const for public
    $entity->{$field_name}->value = 0;
    if ($entity->save() === SAVED_UPDATED) {
      ++$updated;
    }
  }

  return $updated;
}

/**
 * Implements hook_node_access_records().
 */
function private_entity_node_access_records(NodeInterface $node) {

  // This hook is called after saving a node.
  $isPrivate = FALSE;
  $privateFieldName = FieldTools::getFieldNameFromType($node, 'private_entity');
  if (!is_null($privateFieldName) && $node->hasField($privateFieldName)) {
    $privateFieldValue = $node->get($privateFieldName)->getValue();
    // @todo define a field type 'is private' that can be appended on entities.
    // @todo config to set message or not.
    if (isset($privateFieldValue[0]['value'])
      && (int) $privateFieldValue[0]['value'] === 1) {
      $isPrivate = TRUE;
      drupal_set_message(t('This content was set as private.'), 'warning');
    }
    else {
      drupal_set_message(t('This content was set as public.'));
    }
  }

  if ($isPrivate) {
    // If a user can view, it becomes elligible to update or delete.
    // Otherwise just ignore the grant for other accounts.
    $accounts = _private_entity_get_accounts();
    foreach ($accounts as $account) {
      if ($account instanceof AccountInterface) {
        // Evaluation to update or delete can be done here.
        // Or simply during the evaluation of hook_node_grants()
        // but with perf issue.
        // @todo evaluate has permission to update
        $grantUpdate = 0;
        // @todo evaluate has permission to delete
        $grantDelete = 0;
        $grants[] = [
          'realm' => PRIVATE_ENTITY_REALM,
          'gid' => $account->id(),
          'grant_view' => 1,
          'grant_update' => $grantUpdate,
          'grant_delete' => $grantDelete,
          'langcode' => 'en',
        ];
      }
    }

    // Exception for the admin GID.
    $grants[] = [
      'realm' => PRIVATE_ENTITY_REALM,
      'gid' => 0,
      'grant_view' => 1,
      'grant_update' => 1,
      'grant_delete' => 1,
      'langcode' => 'en',
    ];

    return $grants;
  }
}

/**
 * Implements hook_node_grants().
 */
function private_entity_node_grants(AccountInterface $account, $op) {

  // This hook is called each time access to a node needs to be determined.
  $grants = [];

  if (in_array('administrator', $account->getRoles())) {
    // Gid to view, update, delete.
    $grants[PRIVATE_ENTITY_REALM][] = 0;
    return $grants;
  }

  // @todo roles exclusion (bypass access rule) from a new permission
  if ($account->id() != 0) {
    // Otherwise return uid, might match entry in table.
    $grants[PRIVATE_ENTITY_REALM][] = $account->id();
  }

  return $grants;
}

/**
 * Implements hook_ENTITY_TYPE_create().
 */
function private_entity_field_config_create(FieldConfig $field) {
  if ($field->getType() === 'private_entity' && !$field->isSyncing() && !$field->isDeleted()) {
    // Set private_entity values for existing entities.
    $oldCount = _private_entity_init_old_entries(
      $field->getTargetEntityTypeId(),
      $field->getTargetBundle(),
      $field->getFieldStorageDefinition()->getName()
    );

    if ($oldCount > 0) {
      drupal_set_message(t('%count existing entities have been set as public.', [
        '%count' => $oldCount,
      ]));
    }
  }
}
